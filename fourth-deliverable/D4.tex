\documentclass{report}
\usepackage{float}

% for the image in the title
\usepackage{tikz}

% custom spacing
\usepackage{setspace}
\onehalfspacing

% footer and header
\usepackage{fancyhdr}
% \setlength{\headheight}{15.2pt}

% underlining
\usepackage{ulem}

% Table of contents link to corresponding sections
\usepackage{hyperref}
\hypersetup{
	colorlinks,
	citecolor=black,
	filecolor=black,
	linkcolor=black,
	urlcolor=black
}

\usepackage{amsmath}
% Remove che "Chapter" string before chapters
\iffalse
\makeatletter
\def\@makechapterhead#1{%
	\vspace*{50\p@}%
	{\parindent \z@ \raggedright \normalfont
		\interlinepenalty\@M
		\Huge\bfseries  \thechapter.\quad #1\par\nobreak
		\vskip 40\p@
}}
\makeatother
\fi

% Fancy chapters
\usepackage[Bjarne]{fncychap}
% options: Sonny, Lenny, Glenn, Conny, Rejne, Bjarne, Bjornstrup

\begin{document}
	
	
	%title page
	\begin{titlepage}
		\begin{figure}[t]
			\centering\includegraphics[width=0.3\textwidth]{images/unitn-logo}
		\end{figure}
		\begin{center}
			\textsc{ \LARGE{Università degli Studi di Trento \\}}
			\textsc{ \LARGE{Facoltà di Informatica\\ }}
			\textnormal{ \LARGE{Corso di Ingegneria del Software\\}}
			\vspace{30mm}
			\fontsize{10mm}{7mm}\selectfont 
			\textup{Fix Mi \\ Application Implementation and Documentation}\\
		\end{center}
		
		\vspace{25mm}
		
		\centering
		\large Gruppo G43: \\ Giovanni Santini\\ Riginel Ungureanu \\ Valerio Asaro
		
		\vspace{20mm}
		
		\centering{\large{Anno Accademico 2023/2024 \\ Trento }}
		
	\end{titlepage}
	
	
	
	
	% use header and footers
	\pagestyle{fancy}
	\fancyhead[R]{\chaptername\ \thechapter}  % header
	
	%\maketitle
	\tableofcontents
	\newpage
	
	
	
	\section{Scopo del documento}
	
	
	\section{Implementazione}
	
	\section{Informazioni del Documento}
	
	% table
	\begin{center} % center the table
		\centering
		\begin{tabular}{ |p{4cm}|p{4cm}|  }
			\hline
			\centering Campo & \qquad\qquad Valore \\ % I found no other way...
			\hline
			Titolo del Documento & Application Implementation and Documentation \\
			\hline
			Titolo del Progetto & Fix Mi \\
			\hline
			Autori del Documento &
			Giovanni Santini \\ & Riginel Ungureanu \\ & Valerio Asaro \\
			\hline
			Amministratore Progetto & Riginel Ungureanu\\
			\hline
			Versione del documento & 1.0 \\
			\hline
		\end{tabular}
	\end{center}
	
	
	
\chapter{Backend}

Il seguente capitolo descrive l'implementazione, con il supporto di diagrammi "UML" e codice, della parte "Backend" dell'applicazione, in riferimento a quanto detto nei precedenti documenti quali "Analisi dei Requisiti", "Specifica dei Requisiti" e del "Documento di Architettura".  Il capitolo è strutturato partendo da una visione generale dell'infrastruttura, andando verso una visione più specifica e dettagliata.


Gli estratti di codice verranno mostrati nel seguente formato:
\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/example_code_01.png}
	Esempio di estratto di codice
\end{figure}

\subsection*{Tecnologie}

In questo capitolo verranno menzionate più volte alcune tecnologie, dunque ne viene riportata una breve descrizionee sotto:
\begin{itemize}
	\item "Docker": tecnologia che raccoglie il software in unità standardizzate chiamate container, offrendo tutto il necessario per la loro corretta esecuzione, incluse librerie, strumenti di sistema, codice e runtime. Il logo ricorda una balena di colore azzurro con dei rettangoli al di sopra rappresentanti dei containers, come se la balena stessa fosse una nave.
	\item "Docker Compose": software per la gestione di molteplici docker containers contemporaneamente. L'icona rappresenta un polpo con dei parallelepipedi azzurri tra i tentacoli.
	\item "Nginx": intermediario tra le richieste da parte dei client e il server. Può essere usato come load balancer, cache o proxy. Il logo è raffigurato da un N bianca con sfondo verde.
	\item "MongoDB": DBMS non relazionale. Il logo rappresenta una foglia verde.
	\item "Express": framework backend per applicazioni web in javascript. Il logo è formato dalle due lettere "e" e "x" in nero.
	\item "React": framework frontend lo sviluppo di applicazioni web. L'icona ricorda un atomo.
\end{itemize}

\section{Architettura dei Microservizi}

L'architettura proposta si basa sulla divisione logica (e fisica) delle funzionalità dell'applicazione tramite la distinzione di \textit{Microservizi}. Ciascun microservizio è indipendente dagli altri ed è composto a sua volta da una frontend e una backend distinte. Per tale ragione, è più accurato parlare di micro-frontend e micro-backend.

\subsection*{Vantaggi di un'architettura basata su microservizi}

Da un punto di vista di sviluppo, un'architettura non monolitica permette lo sviluppo asincrono dei singoli microservizi, oltre a facilitare la divisione del lavoro nelle varie parti. Tale architettura ha anche dei vantaggi a livello di performance in quanto il carico di lavoro chel'applicazione processa viene distribuito su più processi diminuendo il carico sul singolo. Altri vantaggi sono la scalarità dia una componente dell'applicazione in base alle esigenze e la ridondanza in quanto possono esistere più istanze di un microservizio contemporaneamente.

\subsection*{Svantaggi}

Un'architettura a microservizi è intrinsecamente più complessa nella progettazzione e nella menutenzione rispetto ad una architettura tradizionale. La necessità di orchestrare e mettere in comunicazione i diversi microservizi richiede particolari accortezze nella parte di design e di deploy. Tali problematiche sono state valutate con cura dal team di sviluppo.

\section{Visione Generale}
Prima di analizzare il singolo microservizio, questa sezione illustra una visione generale dell'applicazione e degli strumenti utilizzati per la realizzazione dell'infrastruttura, per poi concentrarsi sulle parti comuni di ogni microservizio e infine sul singolo microservizio.


\subsection*{Infrastruttura}

Si presti attenzione alla seguente infografica dell'infrastruttura implementata:

\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/diagramma_microservizi.png}
	Schema dei microservizi
\end{figure}

L'intera infrastruttura viene inizializzata con \textit{Docker Compose}. In particolare, \textit{Docker Compose} si occupa di impostare i containers sullo stesso network con un IP statico e le variabili di ambiente come le porte e gli IP dei rispettivi microservizi, oltre ad inizializzare i containers, le porte e volumi condivisi.

Se eseguito su un singolo host, il network di default segue la seguente struttura:
\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/network.png}
	Schema del network dei microservizi
\end{figure}

Docker imposta i microservizi sul network 10.5.0.0/24 con i seguenti IP:
	% table
\begin{center} % center the table
	\centering
	\begin{tabular}{ |p{4cm}|p{4cm}|  }
		\hline
		\centering Nome Microservizio & \qquad\quad Network IP \\ % I found no other way...
		\hline
		MongoDB & 10.5.0.10/24 \\
		\hline
		Microservizio Autenticazione & 10.5.0.11/24 \\
		\hline
		Microservizio Task & 10.5.0.12/24 \\
		\hline
		Microservizio Home & 10.5.0.13/24 \\
		\hline
		Microservizio Gestione Dipendenti & 10.5.0.14/24 \\
		\hline
		Reverse Proxy & 127.0.0.1 \\
		\hline
	\end{tabular}
\end{center}

Ad ogni servizio sono state assegnate le seguenti porte:

\begin{center} % center the table
	\centering
	\begin{tabular}{ |p{4cm}|p{4cm}|  }
		\hline
		\centering Nome servizio & \qquad\qquad Porta \\ % I found no other way...
		\hline
		MongoDB & 27017 \\
		\hline
		Backend & 3001 \\
		\hline
		frontend & 3002 \\
		\hline
		Reverse Proxy & 7777 \\
		\hline
	\end{tabular}
\end{center}

Due microservizi particolari sono il database e il reverse proxy. Il database fornisce la possibilità di salvare in modo permanente i dati dell'applicazione, mentre il reverse proxy permette di accedere facilmente all'ip di un microservizio attraverso una mappatura di ip. I software scelti sono rispettivamente \textit{MongoDB} e \textit{Nginx}.

In particolare, \textit{Nginx} associa le routes nel seguente modo:
\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/nginx.png}
	Schema delle routes di Nginx
\end{figure}

\subsection*{Codice: Struttura}

La directory radice del progetto contiene i seguenti files:

\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/tree.png}
    Output del comando "tree", mostra i contenuti della directory root del progetto.
\end{figure}

Segue una descrizione degli stessi:
\begin{itemize}
	\item "db": volume condiviso tra il docker container del database e il filesystem dell'host per mantenere persistenza dei dati quando il container viene riavviato o rimosso.
	\item "docker-compose.yaml": file di configurazione utilizzato da docker compose per inizializzare l'infrastruttura. Contiene le informazioni per avviare gli altri microservizi.
	\item "fixmi-microservice-gestione-dipendenti": cartella contenente il microservizio "Gestione Dipendenti".
	\item "fixmi-microservizio-autenticazione": cartella contenente il microservizio "Autenticazione".
	\item "fixmi-microservizio-home": cartella contenente il microservizio "Home".
	\item "fixmi-microservizio-task": cartella contenente il microservizio "task".
	\item "fixmi-reverse-proxy": cartella contenente il reverse proxy.
	\item "init\_scripts": script per inizializzare il database con dei dati di esempio.
	\item "README.md": contiene informazioni e documentazione sul deploy dell'infrastruttura.
\end{itemize}

\subsection*{Codice: docker-compose.yaml}

Si prenda come esempio questo frammento di codice responsabile del setup del microservizio task:
\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/docker_code_01.png}
	Estratto dal file "docker-compose.yaml"
\end{figure}

In questo codice, notiamo che le porte vengono impostate sotto la sezione "ports", così come i volumi e il network. Le variabili d'ambiente contenenti i vari ip e le credenziali del database sono contenute nel file ".env" presente nella radice della cartella.
La configurazione per gli altri microservizi è simile, con qualche piccola differenza. Qua sotto vengono riportati gli altri microservizi:
\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/yaml_gestione_dipendenti.png}
	Codice responsabile per l'avvio del microservizio "Gestione Dipendenti"
\end{figure}
\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/yaml_autenticazione.png}
	Codice responsabile per l'avvio del microservizio "Autenticazione"
\end{figure}
\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/yaml_home.png}
	Codice responsabile per l'avvio del microservizio "Home"
\end{figure}
\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/yaml_database.png}
	Codice responsabile per l'avvio del database
\end{figure}
\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/yaml_reverse_proxy.png}
	Codice responsabile per l'avvio del reverse proxy
\end{figure}

\subsection*{Codice: nginx.conf}

Il file \textit{nginx.conf} all'interno della cartella \textit{fixmi-reverse-proxy} imposta la configurazione per il reverse proxy. Questo microservizio si occupa di instradare le richieste ai vari microservizi. Segue un'estratto della configurazione:


\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/nginx_config_home.png}
	Estratto da "fixmi-reverse-proxy/nginx.conf", definizione delle routes "/home" e "/api/home"
\end{figure}

La variabile "worker\_connections" definisce il numero di connessioni simultanee che il servizio può gestire. Il blocco "http" e il blocco "server" contengono le configurazioni delle routes, in particolare in questo esempio notiamo che la route "/home/" viene passata a "http://10.5.0.13:3002/" ossia la frontend del microservizio "home", mentre "/api/home/" rimanda a "http://10.5.0.13:3001/api/home/" ossia la backend del microservizio "home". Vengono inoltre impostati alcuni headers dopo la dicitura "proxy\_set\_header".

Di seguito vengono riportate le altre routes:

\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/nginx_config_tasks.png}
	Routes "/tasks" e "/api/tasks"
\end{figure}
\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/nginx_config_dipendenti.png}
	Routes "/dipendenti" e "/api/dipendenti"
\end{figure}
\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/nginx_config_auth.png}
	Routes "/auth" e "/api/auth"
\end{figure}

\subsection*{Codice: init-mongo.js}

Il file contiene l'inizializzazione delle entrate del database in formato json. Sono stati individuati due database: "Tasks" e "Users" e le rispettive collezioni "tasks" e "users" (da notare la differenza della prima lettera da maiuscola a minuscola). I contenuti sono i seguenti:
\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/db-tasks.png}
	Inizializzazione database "Task"
\end{figure}

\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/db-users.png}
	Inizializzazione database "Users"
\end{figure}


\section{Parti comuni ad ogni microservizio}

In questa sezione verrà descritta la struttura che accomuna i vari microservizi.

\subsection{Scelta del Linguaggio}

Il linguaggio scelto per la backend e frontend è \textit{Typescript}: un linguaggio tipizzato che viene tradotto da un compilatore ("transpiler") in Javascript e dunque può essere eseguito in un web browser. Qualsiasi script JavaScript è anche codice TypeScript valido, questo permette all'applicazione di utilizzare l'ampia collezione di pacchetti JavaScript.

\subsection{Frameworks e Dipendenze}

Ogni microservizio utilizza:
\begin{itemize}
	\item \textit{ts-node} v10.9.2: ambiente runtime Typescript open source e multipiattaforma per la creazione del server di backend.
	\item \textit{eslint} v8.56.0: analizzatore di codice statico.
	\item \textit{nodemon} v3.0.3: tool di assistenza per Node.js. permette il riavvio automatico del server quando viene rilevata una modifica nel codice.
	\item \textit{express} v4.18.2: framework web per Node.js, utilizzato per la realizzazione di api.
	\item \textit{React} v18.3.0: libreria UI per javascript, utilizzata per la frontend.
	\item \textit{tailwindcss} v3.4.1: framework CSS.
	\item \textit{Jest} v29.7.0 : framework per il testing
	\item \textit{supertest} v7.0.0: framework per il testing di api, utilizzato insieme a Jest. 
	\item \textit{concurrently} v8.2.2: esegue più comandi contemporaneamente, utilizzato per eseguire frontend e backend insieme.
	\item \textit{serve} v14.2.3: hosta un sito statico, utilizzato per hostare la frontend in produzione.
	\item \textit{dotenv} v16.4.5: permette l'accesso alle variabili di ambiente, utilizzate per la configurazione dei microservizi.
	\item \textit{body-parser} v1.20.2: permette di leggere il body di una richiesta http.
	\item \textit{mongodb} v6.5.0: interfaccia per la connessione al microservizio database.
\end{itemize}

\subsection{Struttura}

La cartella di un microservizio presenta i seguenti files:
\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/structure.png}
	Output del comando "tree" all'interno di un microservizio.
\end{figure}
Segue una descrizione degli stessi, dall'alto verso il basso:
\begin{itemize}
	\item "backend": cartella contenente tutto il codice di Backend in TypeScript.
	\item "build": cartella contenente l'applicazione web statica generata da React.
	\item "commands": cartella contenente degli appunti degli sviluppatori durante la creazione del progetto.
	\item "dist": cartella contenente il codice backend per la produzione, generato dal compilatore di TypeScript.
	\item "Dockerfile": file contenente le istruzioni per la generazione del contenitore di docker.
	\item "nix-shell.nix": file contenente l'ambiente di sviluppo per chi sviluppa su NixOS.
	\item "node\_modules/": cartella contenente i moduli utilizzati dall'applicazione
	\item "package.json": file che definise le dipendenze e le impostazioni di vari moduli.
	\item "package-lock.json": contiene le versioni delle dipendenze dei moduli.
	\item "postcss.config.js": script di configurazione necessario per tailwindcss
	\item "public": contiene file di accesso pubblico per la frontned, come favicon.ico, robots.txt, index.html.
	\item "README.md": contiene le informazioni del progetto e le istruzioni per il deploy.
	\item "src/": cartella contenente tutto il codice per la frontend in tsx.
	\item "tailwind.config.js": file di configurazione per il funzionamento di tailwindcss
	\item "tsconfig.json": configurazione per TypeScript.
\end{itemize}


\subsubsection*{Directory backend/}

\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/tree_backend.png}
	Output del comando "tree" all'interno della cartella "backend/".
\end{figure}


La struttura della directory "backend/" segue il seguente formato:
\begin{itemize}
	\item server.ts: è il file principale. Si occupa di istanziare l'App di express, 
	connettersi al database e definire le route delle API.
	\item classes/ : directory contenente le classi relative ai profili, che vengono manipolate ed immagazzinate nel database.
	\item enums/ : directory contenente gli enumi necessari.
	\item routes/ : directory contenente gli endpoint delle API del sistema.
	\item tests/ : directory contenente i test delle API
	\item utils/ : directory contenente strutture dati e funzioni utili al funzionamento del sistema.
\end{itemize} 

\subsection{Comandi npm}
Vengono definiti i seguenti scripts per l'esecuzione dell'applicazione tramite npm. Ogni comando può esssere eseguito digitando "npm run" ed il nome del comando.
\begin{itemize}
	\item "startfront": esegue solo la frontend, si aggiorna automaticamente ad ogni modifica del codice
	\item "buildfront": genera la frontend statica per la production
	\item "startback": esegue soltanto il server di backend, si aggiorna automaticamente ad ogni modifica del codice
	\item "start": esegue sia la frontend sia la backend in developement mode
	\item "production": esegue sia la frontend sia la backend in production mode
	\item "lint": esegue un'analisi stica del codice
	\item "test": esegue gli script di testing del codice.
\end{itemize}
	

\section{Microservizio Autenticazione}

\section{Microservizio Task}

Questa sezione comprende lo sviluppo e la documentazione del backend del
"Microservizio Task". 

\subsection{Lista delle Risorse}

Segue una lista delle risorse implementate dal microservizio:
\begin{itemize}
	\item "Task": contiene tutte le informazioni e i metodi che appartengono alla classe Task (vedi sotto).
	\item "Crea Task": permette all'utente di creare una nuova task.
	\item "Modifica Stato Task": permette al dipendente o al manager di modificare lo stato di una task.
	\item "Scegli Task": permette al dipendento o al manager di assegnare una task al proprio profilo.
	\item "Get Lista Task In Lavorazione": permette al dipendente o al manager di ottenere la lista delle task con lo status di "In Lavorazione" in formato json.
	\item "Get Lista Task Da Eseguire": permette al dipendente o al manager di ottenere la lista delle task con lo status di "Da Eseguire" in formato json.
	\item "Get Lista Task In Pausa": permette al dipendente o al manager di ottenere la lista delle task con lo status di "In Pausa" in formato json.
	\item "Get Storico Task" permette al dipendente o al manager di ottenere la lista delle task con lo status di "Completata" in formato json. Il dipendente rivecerà le tasks che gli sono state assegnate e che sono completate, mentre il dipendente riceverà in risposta tutte le task completate da ogni dipendente.
\end{itemize}

\subsection{Specifica delle Risorse}

Per ogni risorsa elencata nella sezione precedente, si descrive la risorsa attraverso l'utilizzo di illustrazioni e testo.

\subsection*{Task}

La risorsa "Task" implementa la classe "Task" vista nel "Documento di Architettura".

\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/resource_task.png}
	Diagramma della risorsa "Task".
\end{figure}

Segeue l'implementazione nel linguaggio "Typescript":

\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/code_task.png}
	File situato in "backend/classes/Task.ts".
\end{figure}

\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/code_task_magazzino.png}
	File situato in "backend/classes/TaskMagazzino.ts".
\end{figure}

\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/code_task_negozio.png}
	File situato in "backend/classes/TaskNegozio.ts".
\end{figure}

\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/code_task_riparazione.png}
	File situato in "backend/classes/TaskRiparazione.ts".
\end{figure}

\begin{figure}[H]
	\centering\includegraphics[width=0.9\textwidth]{images/code_task_supporto.png}
	
	File situato in "backend/classes/TaskSupporto.ts".
\end{figure}

\begin{figure}[H]
	\centering\includegraphics[width=0.9\textwidth]{images/code_task_assistenza.png}
	
	File situato in "backend/classes/TaskAssistenza.ts".
\end{figure}

\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/code_task_feedback.png}
	File situato in "backend/classes/TaskFeedback.ts".
\end{figure}




\subsection*{Scegli Task}

\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/scegli_task_model.png}
	Diagramma delle risorse per l'API "Scegli Task".
\end{figure}

La risorsa "Scegli Task", accessibile tramite la route "/api/tasks/scegliTask" permette di assegnare una task ad un dipendente o ad un manager. L'API richiede tutti i seguenti campi:

\begin{itemize}
	\item "token": il codice numerico che identifica una sessione autenticata, ottenuto attraverso il microservizio autenticazione.
	\item "taskId": il codice univoco che identifica una task nel database.
\end{itemize}

La response body `e in formato application/json. Di seguito le possibili risposte:

% table
\begin{center} % center the table
	\centering
	\begin{tabular}{ |p{4cm}|p{4cm}|p{4cm}| }
		\hline
		\centering Status Code & \qquad\qquad\quad Body & \qquad\quad Spiegazione\\ % I found no other way...
		\hline
		200 OK & \{Success: "task assigned to the user" \}  & La procedura è terminata con successo	\\ 
		\hline
		400 BAD REQUEST & \{error: "missing fields", missingFields \} & I campi richiesti sono mancanti. \\
		\hline
		401 UNAUTHORIZED & \{ error: "User not found with the given token" \} & Il token non è valido \\
		\hline
		403 FORBIDDEN & \{ error: "User not authorized" \} &  L'utente non ha permessi elevati per accedere all'API \\
		\hline
		404 NOT FOUND & \{ error: "Task not found" \} & Non è stata trovata alcuna task con il taskid inviato. \\
		\hline
	\end{tabular}
\end{center}

Di seguito viene derscitta la risorsa secondo OpenAPI specification:


\begin{verbatim}
openapi: 3.0.3
    info:
    title: Seleziona Task
    version: 1.0.0
    description: Permette di assegnare una
                 task ad un dipendente o ad un manager
paths:
    /api/tasks/scegliTask:
    post:
        requestBody:
            required: true
            content:
                application/json:
                    schema:
                        type: object
                        properties:
                            token:
                                type: string
                                description: Il token ottenuto attraverso
                                             il microservizio autenticazione.
                                example: 171595638452613
                            taskid:
                                type: string
                                description: L'identificativo univoco
                                             della task
                                example: 66476aa0726f8460bce4a26d
                        required:
                            - token
                            - taskid
        responses:
            '200':
                description: Task assigned to the user
                content:
                    application/json:
                    schema:
                        type: object
                        properties:
                            Success:
                               type: string
                                example: "Task assigned to the user"
            '400':
                description: Bad Request
                content:
                    application/json:
                        schema:
                            type: object
                            properties:
                                error:
                                    type: string
                                    example: "missing fields"
                                missingFields:
                                    type: array
                                    items:
                                    type: string
                                    example: token
                            required:
                                - error
                                - missingFields
            '401':
                description: Unauthorized
                content:
                    application/json:
                        schema:
                            type: object
                            properties:
                                error:
                                    type: string
                                    example: "user not found with
                                              the given token"
                            required:
                               - error
            '403':
                description: Forbidden
                content:
                    application/json:
                        schema:
                            type: object
                                properties:
                                    error:
                                        type: string
                                        example: "User not authorized"
                                    required:
                                        - error
            '404':
                description: Not Found
                content:
                    application/json:
                        schema:
                            type: object
                                properties:
                                    error:
                                        type: string
                                        example: "taskidask not found"
                                required:
                                    - error
	
	
\end{verbatim}

Il codice che implementa quanto detto sopra è il seguente:

\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/code_scegli_task.png}
	Codice estratto da "backend/routes/scegliTaskRouter.ts".
\end{figure}
\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/code_task_exists.png}
	Funzione "taskExists()".
\end{figure}
\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/code_scegli_task_query.png}
	Funzione "executeQuery()".
\end{figure}

Sono stati realizzati i seguenti tests per coprire ogni possibile risultato della chiamata:
\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/code_scegli_task_test1.png}
\end{figure}
\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/code_scegli_task_test2.png}
\end{figure}
\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/code_scegli_task_test3.png}
\end{figure}
\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/code_scegli_task_test4.png}
\end{figure}
\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/code_scegli_task_test5.png}
\end{figure}
\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/code_scegli_task_test6.png}
\end{figure}



\subsection*{Modifica Stato Task}


\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/model_modifica_task.png}
	
	Modello delle risorse per "/api/tasks/modificaStatoTask".
\end{figure}

La risorsa "Modifica Stato Task" è accessibile tramite la route "/api/tasks/modificaStatoTask". Permette al dipendente o al manager di impostare un nuovo stato ad una task presente nel database. Gli stati possibili sono definiti nell'enum TaskStatus e sono i seguenti: "DaEseguire", "InLavorazione", "InPausa". "Completata".

\begin{figure}[H]
	\centering\includegraphics[width=1\textwidth]{images/code_enum_taskStatus.png}
	
	Definizione dell'enum "TaskStatus" in "backend/enums/TaskStatus.ts".
\end{figure}

La risorsa richiede tutti i seguenti campi nel body:
\begin{itemize}
	\item "taskid": identificativo univoco di una task
	\item "token": token ottenuto dal microservizio autenticazione
	\item "taskStatus": il nuovo stato che verrà impostato nella task
\end{itemize}

Il corpo della risposta è in formato application/json e riporta le seguenti risposte:

\begin{center} % center the table
	\centering
	\begin{tabular}{ |p{4cm}|p{4cm}|p{4cm}| }
		\hline
		\centering Status Code & \qquad\qquad\quad Body & \qquad\quad Spiegazione\\ % I found no other way...
		\hline
		200 OK & \{Success: "Task status changed succesfully" \}  & La procedura è terminata con successo	\\ 
		\hline
		400 BAD REQUEST & \{error: "missing fields", missingFields \} & I campi richiesti sono mancanti. \\
		\hline
		400 BAD REQUEST & \{error: "Wrong status", missingFields \} & Lo status inviato non è valido (non corrisponde ad uno dei valori dell'enum). \\
		\hline
		401 UNAUTHORIZED & \{ error: "User not found with the given token" \} & Il token non è valido \\
		\hline
		403 FORBIDDEN & \{ error: "User not authorized" \} &  L'utente non ha permessi elevati per accedere all'API \\
		\hline
		404 NOT FOUND & \{ error: "Task not found" \} & Non è stata trovata alcuna task con il taskid inviato. \\
		\hline
	\end{tabular}
\end{center}

Segue la definizione secondo OpenAPI:

\begin{verbatim}
openapi: 3.0.3
    info:
    title: Task Status Modification API
    version: 1.0.0
paths:
    /api/tasks/modificaStatoTask:
        post:
            summary: Change task status
            description: Questa route permette al dipendente o al
                         manager di cambiare lo stato di una task.
            requestBody:
                required: true
                content:
                    application/json:
                        schema:
                            type: object
                            properties:
                                token:
                                    type: string
                                    description: Il token dell'utente
                                    example: 171595638452613
                                taskid:
                                    type: string
                                    description: Identificativo della task
                                    example: 66476aa0726f8460bce4a26d
                                taskStatus:
                                    type: TaskStatus
                                    description: Il nuovo stato della task.
                                    example: Completata
                            required:
                                - token
                                - taskid
                                - taskStatus
            responses:
                '200':
                    description: Task status changed successfully
                        content:
                            application/json:
                                schema:
                                    type: objectà
                                    properties:
                                        Success:
                                            type: string
                                            example: "Task status
                                                      changed successfully"
                '400':
                    description: Bad Request
                    content:
                        application/json:
                            schema:
                                type: object
                                properties:
                                    error:
                                        type: string
                                        example: "missing fields"
                                    missingFields:
                                        type: array
                                    items:
                                        type: string
                                required:
                                    - error
                                    - missingFields
                '401':
                    description: Unauthorized
                    content:
                        application/json:
                            schema:
                                type: object
                                properties:
                                    error:
                                        type: string
                                        example: "user not found
                                                  with the given token"
                                required:
                                    - error
                '403':
                    description: Forbidden
                    content:
                        application/json:
                            schema:
                                type: object
                                properties:
                                    error:
                                        type: string
                                        example: "User not authorized"
                                required:
                                    - error
                '404':
                    description: Not Found
                    content:
                        application/json:
                            schema:
                                type: object
                                properties:
                                    error:
                                        type: string
                                        example: "Task not found"
                               required:
                                   - error
\end{verbatim}

Il codice è il seguente:
\begin{figure}[H]
	\centering\includegraphics[width=0.8\textwidth]{images/code_modifica_stato.png}
	
	Estratto da "backend/routes/modificaStatoTask".
\end{figure}
\begin{figure}[H]
	\centering\includegraphics[width=0.8\textwidth]{images/code_modifica_stato_query.png}
	
	Funzione "checkStatus()" e "executeQuery()".
\end{figure}

Sono stati creati i seguenti tests:

\begin{figure}[H]
	\centering\includegraphics[width=0.8\textwidth]{images/code_modifica_stato_test1.png}
\end{figure}
\begin{figure}[H]
	\centering\includegraphics[width=0.8\textwidth]{images/code_modifica_stato_test2.png}
\end{figure}
\begin{figure}[H]
	\centering\includegraphics[width=0.8\textwidth]{images/code_modifica_stato_test3.png}
\end{figure}
\begin{figure}[H]
	\centering\includegraphics[width=0.8\textwidth]{images/code_modifica_stato_test4.png}
\end{figure}
\begin{figure}[H]
	\centering\includegraphics[width=0.8\textwidth]{images/code_modifica_stato_test5.png}
\end{figure}
\begin{figure}[H]
	\centering\includegraphics[width=0.8\textwidth]{images/code_modifica_stato_test6.png}
\end{figure}


\subsection*{Get Lista Task In Lavorazione}

\subsection*{Get Lista Task Da Eseguire}

\subsection*{Get Lista Task In Pausa}

\subsection*{Get Storico Task}

\subsection*{Crea Task}

\subsection*{Testing routes}

\subsubsection*{Greet}
\subsubsection*{Test Task}
\subsubsection*{Test DB}

\section{Microservizio Gestione Dipendenti}

\section{Microservizio Home}

\chapter{Frontend}

	
\end{document}